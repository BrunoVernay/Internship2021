# Commercial Products

**Table of Contents**


- HTTP Protocol
	* [Mayhem](https://github.com/pinkhat-m/Internship2021/blob/master/CommercialProducts.md#mayhem)
	* [BooFuzz](https://github.com/pinkhat-m/Internship2021/blob/master/CommercialProducts.md#boofuzz---http--modbus)
	* [Peach](https://github.com/pinkhat-m/Internship2021/blob/master/CommercialProducts.md#peach---http--modbus)
	* [beSTORM](https://github.com/pinkhat-m/Internship2021/blob/master/CommercialProducts.md#bestorm---modbus-protocol)
	* [AFLNet](https://github.com/pinkhat-m/Internship2021/blob/master/CommercialProducts.md#aflnet-a-greybox-fuzzer-for-network-protocolsstateful-coverage-based-greybox-fuzzing)
	* [APIFuzzer](https://github.com/pinkhat-m/Internship2021/blob/master/CommercialProducts.md#apifuzzer--http-api-testing-framework)
	* [Fuzz-testing HTTP endpoints](https://github.com/pinkhat-m/Internship2021/blob/master/CommercialProducts.md#fuzz-testing-http-endpointsartillery)
	* [HTTP-FUZZER](https://github.com/pinkhat-m/Internship2021/blob/master/CommercialProducts.md#http-fuzzer)
	* [Wfuzz](https://github.com/pinkhat-m/Internship2021/blob/master/CommercialProducts.md#wfuzz)
	* [SoapUI](https://github.com/pinkhat-m/Internship2021/blob/master/CommercialProducts.md#soapui)

- Modbus Protocol
	* [BooFuzz](https://github.com/pinkhat-m/Internship2021/blob/master/CommercialProducts.md#boofuzz---http--modbus)
	* [Peach](https://github.com/pinkhat-m/Internship2021/blob/master/CommercialProducts.md#peach---http--modbus)
	* [beSTORM](https://github.com/pinkhat-m/Internship2021/blob/master/CommercialProducts.md#bestorm---modbus-protocol)
	* [Fuzzowski](https://github.com/pinkhat-m/Internship2021/blob/master/CommercialProducts.md#fuzzowski)
	* [Defensic](https://github.com/pinkhat-m/Internship2021/blob/master/CommercialProducts.md#defensic)
	* [Aegis](https://github.com/pinkhat-m/Internship2021/blob/master/CommercialProducts.md#aegis-2014)



<table>
    <thead>
        <tr>
            <th>Tools</th>
            <th>Company</th>
            <th>Open-source</th>
   	        <th>Protocol(s)</th>
            <th>Priority*</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><b>Mayhem</td>
            <td><a href= "https://forallsecure.com/">ForAllSecure</a></td>
            <td>30-day free trial</td>
            <td>HTTP</td>
			<td>1</td>
        </tr>
        <tr>
            <td><b>BooFuzz</td>
			<td><a href= "https://github.com/jtpereyda">jtpereyda</a></td>
			<td>Yes</td>
            <td>HTTP/Modbus</td>			
			<td>4</td>
        </tr>
        <tr>
            <td><b>Peach</td>
			<td><a href="https://about.gitlab.com/">GitLab</a></td>
			<td>30-day free trial</td>
            <td>HTTP/Modbus</td>			
			<td>1</td>
        </tr>
        <tr>
            <td><b>beSTORM</td>
			<td><a href="https://beyondsecurity.com/">Beyond Security</a></td>
			<td>Free trial</td>
            <td>HTTP/Modbus</td>			
			<td>3</td>
        </tr>
        <tr>
            <td><b>AFL<sub>NET</sub></td>
			<td><a href="">Michal Zalewski</a></td>
			<td>Yes</td>
            <td>HTTP</td>			
			<td>2</td>
        </tr>
        <tr>
            <td><b>APIFuzzer</td>
			<td><a href="https://github.com/KissPeter">Péter Kiss</a></td>
			<td>Yes</td>
            <td>HTTP</td>			
			<td></td>
        </tr>
        <tr>
            <td><b>Fuzz-testing HTTP endpoints(Plugin)</td>
			<td><a href="https://artillery.io/">Artillery</a></td>
			<td>Yes</td>
            <td>HTTP</td>			
			<td></td>
        </tr>
        <tr>
            <td><b>HTTP-Fuzzer</td>
			<td><a href="https://github.com/tehmoon">Tehmoon</a></td>
			<td>Yes</td>
            <td>HTTP</td>			
			<td></td>
        </tr>
        <tr>
            <td><b>Wfuzz</td>
			<td><a href="http://wfuzz.io/">Wfuzz</a></td>
			<td>Yes</td>
            <td>HTTP</td>			
			<td></td>
        </tr>
        <tr>
            <td><b>SoapUI/ReadyAPI(Morefeatures)</td>
			<td><a href="https://smartbear.com/">SmartBear</a></td>
			<td>Yes/14-day free trial</td>
            <td>HTTP</td>			
			<td></td>
        </tr>           
        <tr>
            <td><b>Fuzzowski</td>
			<td><a href="https://www.nccgroup.com/">NCC Group Plc</a></td>
			<td>Yes</td>
            <td>Modbus</td>			
			<td></td>
        </tr>
        <tr>
            <td><b>Defensic</td>
			<td><a href="https://www.synopsys.com/">Synopsys</a></td>
			<td>No</td>
            <td>Modbus</td>			
			<td></td>
        </tr>         
        <tr>
            <td><b>Aegis</td>
			<td><a href="https://stepfunc.io/">Step Function I/O</a></td>
			<td>No</td>
            <td>Modbus</td>			
			<td></td>
        </tr>                                                              
    </tbody> 
</table>
* Priority is for arranging the tools in the best order in terms of performance. 1 has a higher priority.


## Mayhem
<https://forallsecure.com/blog/top-3-technical-barriers-to-fuzzing>

<https://forallsecure.com/blog/demystifying-a-docker-image>

<https://go.forallsecure.com/hubfs/Content/Solution-Briefs/br-mayhem-for-api-solution-brief.pdf>

<https://go.forallsecure.com/hubfs/Content/Solution-Briefs/br-mayhem-solution-brief.pdf?hsLang=en>

Advanced fuzzing technique integrating symbolic execution and guided fuzzer; it also conducts regression and component testing, and fits directly into the DevOps workflow. 

Advantages:

- Fuzz testing that uncovers deep defects.
- Actionable results with zero-false positive rates.
- Autonomous testing at machine speed and scale.
- DevOps flexibility shift-lefts dynamic negative testing.
- Manage inherited risk from an unchecked supply chain.

Fuzzing techniques: AFL, Honggfuzz, LibFuzzer

###### Honggfuzz
<https://github.com/google/honggfuzz>
A security oriented, feedback-driven, evolutionary, easy-to-use fuzzer with interesting analysis options.

(Apache **HTTPD**,...)

## Stateful Blackbox Fuzzing (SBF)

Several SBF tools in academia:  Sulley, **BooFuzz**, 
and in the industry: **Peach**, **beSTORM**

### BooFuzz - _HTTP & Modbus_
https://boofuzz.readthedocs.io/en/stable/user/install.html

<https://boofuzz.readthedocs.io/en/stable/>

Boofuzz features:

- Easy and quick data generation.
- Instrumentation – AKA failure detection.
- Target reset after failure.
- Recording of test data.
- Much easier install experience!
- Support for arbitrary communications mediums.
- Built-in support for serial fuzzing, ethernet- and IP-layer, UDP broadcast.
- Better recording of test data – consistent, thorough, clear.
- Test result CSV export.
- Extensible instrumentation/failure detection.
- Far fewer bugs.

### Peach - _HTTP & Modbus_
The Peach Fuzzer Platform uses automated generative and mutational modeling and intelligent test case generation to reveal the hidden bugs.
<https://gitlab.com/gitlab-org/security-products/protocol-fuzzer-ce>

##### **DevSecOps**
<https://about.gitlab.com/solutions/dev-sec-ops/>

- Continuous security testing capabilities
- Static Application Security Testing (SAST)
- Dynamic Application Security Testing (DAST)
- Dependency Scanning
- Container Scanning
- License Compliance
- Auto Remediation
- Secret Detection
- Fuzz Testing: Fuzzit(Coverage-guided Fuzz Testing), API Fuzz Testing/Peach(Behavioral Fuzz Testing)
	<https://www.youtube.com/c/GitLabUnfiltered/search?query=fuzz>

### **beSTORM** - _Modbus Protocol_
<https://beyondsecurity.com/fuzzer-bestorm-whitepaper-2.html?cn-reloaded=1>

<https://beyondsecurity.com/dynamic-fuzzing-testing-modbus-protocol.html>  ////// **Modbus Protocol**

It is equipped with prioritization algorithms to enable complete coverage of all inputs that are likely to 'trigger' a security hole, all within a reasonable time frame.

Discover code weaknesses and certify the security strength of any product without access to source code. Test any protocol or hardware with beSTORM, even those used in IoT, process control, automotive and aerospace.

The beSTORM modules support both non-interactive protocols (such as **HTTP**, possibly the most common protocol in any Internet environment; used by web servers, communication products, and many others), and interactive protocols such as SMTP (used by mail servers, content filtering devices and anti-virus gateways).

beSTORM is expected to find the majority of vulnerabilities that a manual test would reveal within the first 24 hours of automated testing. The full test is expected to take several days to several months – depending on the size and complexity of the application. Distributed capabilities enable to shorten this time considerably by sharing the task between multiple machines. In any event, the testing is completely automated and requires no manual intervention.

## AFLNet: A Greybox Fuzzer for Network Protocols(stateful Coverage-based Greybox Fuzzing)
<https://github.com/aflnet/aflnet>

**AFLNet** is a greybox fuzzer for protocol implementations. Unlike existing protocol fuzzers, it takes a mutational approach and uses state-feedback, in addition to code-coverage feedback, to guide the fuzzing process. AFLNet is seeded with a corpus of recorded message exchanges between the server and an actual client. No protocol specification or message grammars are required. It acts as a client and replays variations of the original sequence of messages sent to the server and retains those variations that were effective at increasing the coverage of the code or state space. To identify the server states that are exercised by a message sequence, AFLNet uses the server’s response codes. From this feedback, AFLNet identifies progressive regions in the state space, and systematically steers towards such regions.

## APIFuzzer — HTTP API Testing Framework
<https://pypi.org/project/APIFuzzer/>

**APIFuzzer** reads your API description and step by step fuzzes the fields to validate if you application can cope with the fuzzed parameters. Does not require coding.

APIFuzzer main **features**:

- Parse API definition from local file or remote URL
- JSON and YAML file format support
- All HTTP methods are supported
- Fuzzing of request body, query string, path parameter and request header are supported
- Support CI integration
	- Generate JUnit XML test report format
	- Send request to alternative URL
	- Support HTTP basic auth from configuration
	- Save report of failed test in JSON format into the pre-configured folder
	- Log to stdout instead of syslog
- Configurable log level

## Fuzz-testing HTTP endpoints(Plugin)
<https://artillery.io/docs/guides/plugins/plugin-fuzzer.html>

The plugin lets you use Artillery to send a lot of unexpected and weird payloads to your API endpoints. You can then monitor your backend for exceptions, errors or crashes, and improve security and reliability of your system by fixing any issues uncovered.

The payloads generated by this plugin are based on [the Big List Of Naughty Strings](https://github.com/minimaxir/big-list-of-naughty-strings/) which contains a large number of inputs that are more likely to trigger unexpected behavior in your software.

## HTTP-FUZZER
<https://github.com/tehmoon/http-fuzzer>

This project **features**:

- Burp compatible
- Easy templating with Go template package
- Multi-threaded
- Multi architecture support
- Save both templated request AND response to temporary directory every time
- Wfuzz API compatible
- Use random user agent on EACH query to cover your tracks
- Use alternative wordlist to be processed for each word in the wordlist
- Follow specified number of redirects
- Throttling feature to avoid being banned

## Wfuzz
<https://wfuzz.readthedocs.io/en/latest/>

<https://github.com/xmendez/wfuzz>

**Wfuzz** is more than a web content scanner:

- Wfuzz could help you to secure your web applications by finding and exploiting web application vulnerabilities. Wfuzz’s web application vulnerability scanner is supported by plugins.

- Wfuzz is a completely modular framework and makes it easy for even the newest of Python developers to contribute. Building plugins is simple and takes little more than a few minutes.

- Wfuzz exposes a simple language interface to the previous HTTP requests/responses performed using Wfuzz or other tools, such as Burp. This allows you to perform manual and semi-automatic tests with full context and understanding of your actions, without relying on a web application scanner underlying implementation.

## SoapUI/ReadyAPI
<https://www.soapui.org/downloads/soapui/>

<https://www.soapui.org/learn/security/security-vulnerability-testing/#_ga=2.84391961.16581309.1615304739-191207751.1615304739>

SoapUI is the world's leading Functional Testing tool for SOAP and REST testing. With its easy-to-use graphical interface, and enterprise-class features, SoapUI allows you to easily and rapidly create and execute automated functional, regression, and load tests. In a single test environment, SoapUI provides complete test coverage - from SOAP and REST-based Web services, to JMS enterprise messaging layers, databases, Rich Internet Applications, and much more. And that's just the beginning.

SoapUI: Open-source version / ReadyAPI(More features): has a trial version

## Fuzzowski
<https://github.com/nccgroup/fuzzowski>

Protocols implemented
- LPD (Line Printing Daemon): Fully implemented
- IPP (Internet Printing Protocol): Partially implemented
- BACnet (Building Automation and Control networks Protocol): Partially implemented
- **Modbus** (ICS communication protocol): Partially implemented

More explanation on ICS protocols: <https://1modm.github.io/Fuzzing_ICS_protocols.html>

## Defensic
<https://www.synopsys.com/software-integrity/security-testing/fuzz-testing.html>

<https://community.synopsys.com/s/article/How-to-Fuzz-test-Modbus-Master-and-PLC-devices>

is a commercial automated fuzzing framework with support for a wide variety of ICS protocols such as **Modbus**, Profinet, DNP3, OPC, BACnet, IEC104 and more.

**Defensics** is a black box fuzzer, meaning it doesn’t require source code to run. With Defensics, users can secure their cyber supply chain to ensure the interoperability, robustness, quality, and security of software and devices before introducing them into IT or lab environments.

## Aegis
<https://stepfunc.io/products/aegis-fuzzer/>

<https://github.com/ITI/ICS-Security-Tools/blob/master/tools/mirrored/aegis-opensource/manual.pdf>

is a smart fuzzing framework for **Modbus**, DNP3 and the IEC104 protocol. 

**Aegis** is a smart fuzzer for power system protocols that can identify robustness and security issues in communications software before it is deployed in a production system.